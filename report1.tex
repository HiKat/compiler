\documentclass[a4j,dvipdfmx]{jarticle}
\usepackage[dvipdfmx]{graphicx}
\usepackage{multirow}
\usepackage[dvipdfmx]{color}
\usepackage{lscape}
\usepackage{ascmac}
\usepackage{here}
\usepackage{txfonts}
\usepackage{listings, jlisting}
\renewcommand{\lstlistingname}{リスト}
\lstset{
  basicstyle=\ttfamily\scriptsize,
  commentstyle=\textit,
  classoffset=1,
  keywordstyle=\bfseries,
  frame=tRBl,
  framesep=5pt,
  showstringspaces=true,
  numbers=left,
  stepnumber=1,
  numberstyle=\tiny,
  tabsize=2
}
%subsubsubsectionの定義
\makeatletter
\newcommand{\subsubsubsection}{\@startsection{paragraph}{4}{\z@}%
  {1.0\Cvs \@plus.5\Cdp \@minus.2\Cdp}%
  {.1\Cvs \@plus.3\Cdp}%
  {\reset@font\sffamily\normalsize}
}
\makeatother
\setcounter{secnumdepth}{4}
%ここまでsubsubsubsectionの定義

\begin{document}

\title{計算機科学実験及び演習3\\ソフトウェア実験中間レポート1}
\author{工学部情報学科3回生 1029255242\\勝見久央}
\date{作成日: \today} % コンパイル時の日付が自動で挿入される
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{課題1}
この課題ではSmall Cの文法に従ってソーティングプログラムを作成した.なお、Small Cでは
BNFの記述からC言語と異なって、
関数内部で変数宣言を全て行ってから変数への値の代入を
行わないとエラーが発生することに留意する.

\subsection{課題1の回答}
コードは次のようになった.
\lstinputlisting[caption=Small Cで記述したバブルソードプログラム,breaklines=true]
{./kadai01.sc}
\section{課題5}
この課題ではSmall Cの構文解析器を作成した.
この構文解析器は
プログラムを受け取って抽象構文木を主な終端記号の位置情報を含んだ形で返す.
\subsection{課題5の回答}
コードは次のようになった.
\lstinputlisting[caption=構文解析器のプログラム]
{./kadai05.rkt}
\subsection{設計方針}
この構文解析器は構文解析の際に
プログラム（文字列）-$>$トークン列 -$>$抽象構文木
という2段階の流れをとっている.
すなわち、構文解析器はプログラムをトークンに置き換える部分と
トークンの列から抽象構文着を作成する部分からなる.
\subsection{各部の説明}
前節で述べた
「プログラム（文字列）-$>$トークン列」
の変換を行うのが関数sub-program-lexerである。
この関数内部では関数lexer-src-posが使われており、
これは指定した文字列もしくは指定した文字列に対応するトークンを文字列中に発見したときに
返すトークンを個別に指定できる関数である.
また、lexer-src-posの返り値には位置情報が含まれる.
なお、特定の文字列、正規表現とトークンの対応付けはdefine-lex-abbrevsで定義し、
その他のトークンはdefine-empty-tokensで定義される.
次に、「トークン列 -$>$抽象構文木」
の変換においては、
Small CのBNFの非終端記号の終端記号への置換えをparser関数のgrammerで指定している.
ここでは特定の非終端記号もしくは終端記号を解析したときに起こすアクションを
それぞれ個別に指定できる.
このプログラムの場合は抽象構文木のノードとなる構造体を返す.
また、それらの構造体はプログラムの冒頭部分で\#:transparentをつけて定義している.
なお、プログラムの実行は、関数parse-stringに文字列としてプログラムを直接渡すか、
ファイルからポートオブジェクトを生成して関数parse-portに渡すことで行う.
\section{課題6}
この課題では、課題5のプログラムを使って実際に構文解析を行う.
\subsection{課題6の実行結果}
test.scに次のような内容を記述する.
\lstinputlisting[caption=解析対象の例]
{./test.sc}
これをポートオブジェクトに変換して構文解析を行った.
\lstinputlisting[caption=構文解析器プログラムの実行例]
                {./kadai06result.rkt}
さらに、例えばtest.scの内容を
\lstinputlisting[]
                {./test2.sc}
と書き換えて同様に構文解析を行うと、
構文解析器は停止し、何も出力しない.
また処理系のDr.Racket側ではエラーが
\begin{verbatim}
  parse error: + #f
\end{verbatim}
と出力され、文字列を右側から構文解析し、
\begin{verbatim}
= +
\end{verbatim}
という文字列を読み取った途端このプログラムが定義していたBNFから外れたことを
発見し、エラーを出力している事がわかる.
\section{課題7}
この課題では、課題5の内容とは逆に、抽象構文木を受け取って、
プログラムとして文字列を返すような関数を作成する.
\subsection{課題7の回答}
コードは次のようになった.
\lstinputlisting[caption=抽象構文器をプログラムに変換する関数]
{./kadai07.rkt}
実行結果は以下のようになった.
\lstinputlisting[caption=プログラムへの変換例]
{./kadai07result.rkt}
\subsection{設計方針}
このプログラムは抽象構文木として受け取ったプログラムを文字列に変換する.
具体的には抽象構文木の構造体の種類によって行う処理を１つずつcond文で定める.
また、受け取る抽象構文木は構造体を属性値として持つ構造体であるから、
この動作を再帰的に繰り返すプログラムを作成する.
\subsection{各部の説明}
このプログラムは、構造体を受け取って受け取った構造体の種類に応じて
様々な処理を行う関数syn-to-codeを再帰的に定義することで作成されている.
基本的にはある構造体をsyn-to-codeが受け取ったら、
その中の属性である構造体を再びsyn-to-codeに渡し、
その結果をstring-appendでつなぐという設計をとっている.
ただし、属性の数が任意の個数の構造体もしくはシンボルになり得るような構造体、
すなわち、関数定義の際の引数のリスト等を処理する際は、他のものと同じような再帰的処理の方法では
カンマの数が不適当になるため、別の関数を用意する必要がある.それらは
関数dec-list-to-code、para-list-to-code、arg-list-to-code
として定義されている.
\section{感想}
今回の実験では前年度のコンパイラの授業を受けてコンパイラの作成をするということで、
その初期段階として構文解析器を作成しましたが、
コンパイラの授業がなかなか理解できず苦戦した僕にとっては非常に苦労した課題でした.
しかし実際に作ってみると去年なかなか理解できなかったものが意外とすんなりと理解でき、
作りながら理解するという実験の恩恵をストレートに感じることが出来ました.
\end{document}
